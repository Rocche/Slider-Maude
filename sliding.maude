fmod COORDS is
    protecting INT .

    sort Coords .

    op _;_ : Int Int -> Coords [ ctor prec 35 ] .

    ---used for searching function in matrix
    vars x y w z : Int .
    op incrementRow : Coords -> Coords .
    eq incrementRow(x ; y) = (x + 1) ; y .

    op incrementCol : Coords -> Coords .
    eq incrementCol(x ; y) = x ; (y + 1) .

    op decrementRow : Coords -> Coords .
    eq decrementRow(x ; y) = (x - 1) ; y .

    op decrementCol : Coords -> Coords .
    eq decrementCol(x ; y) = x ; (y - 1) .

    op calculateDistance : Coords Coords -> Int .
    eq calculateDistance((x ; y), (w ; z)) = abs(x - w) + abs(y - z) .

endfm

fmod TILE is
    protecting COORDS .

    sort Value .

    ops one two three four five six seven eight empty : -> Value [ ctor ] .

    var tile : Value .
    var c : Coords .

    op getCorrectPlace : Value -> Coords .
    eq getCorrectPlace(one) = (0 ; 0) .
    eq getCorrectPlace(two) = (0 ; 1) .
    eq getCorrectPlace(three) = (0 ; 2) .
    eq getCorrectPlace(four) = (1 ; 0) .
    eq getCorrectPlace(five) = (1 ; 1) .
    eq getCorrectPlace(six) = (1 ; 2) .
    eq getCorrectPlace(seven) = (2 ; 0) .
    eq getCorrectPlace(eight) = (2 ; 1) .

    op isTileInCorrectPlace : Value Coords -> Bool .
    ceq isTileInCorrectPlace(tile, c) = true if c == getCorrectPlace(tile) .
    eq isTileInCorrectPlace(tile, c) = false [ owise ] .

endfm


fmod VECTOR is
    protecting INT .
    sorts Element Vector .
    subsort Element < Vector .

    op _,_ : Vector Vector -> Vector [ assoc id: nil prec 40 ] .
    op nil : -> Element [ ctor ] .

    op len : Vector -> Int .

    var head : Element .
    var tail : Vector .
    eq len(nil) = 0 .
    eq len(head, tail) = 1 + len(tail) .

    var N : Int .

    op getElementByIndex : Vector Int -> Element .
    ---eq getElementByIndex(nil, N) = nil .
    eq getElementByIndex(head, tail, 0) = head .
    eq getElementByIndex(head, tail, N) = getElementByIndex(tail, N - 1) .

    var E : Element .
    
    op insertElementIntoVector : Vector Element Int -> Vector .
    eq insertElementIntoVector((head, tail), E, 0) = E, tail .
    eq insertElementIntoVector((head, tail), E, N) = head, insertElementIntoVector(tail, E, N - 1) [ owise ] . 

endfm

fmod MATRIX is
    protecting VECTOR .
    sort Matrix .
    subsort Vector < Matrix .

    op _|_ : Matrix Matrix -> Matrix [ assoc id: mnil prec 45 ] .
    op mnil : -> Matrix [ ctor ] .

    var m_head : Vector .
    var m_tail : Matrix .
    vars row col : Int .

    op getElementByIndexes : Matrix Int Int -> Element .
    eq getElementByIndexes(mnil, row, col) = getElementByIndex(nil, col) .
    eq getElementByIndexes(m_head | m_tail, 0, col) = getElementByIndex(m_head, col) .
    eq getElementByIndexes(m_head | m_tail, row, col) = getElementByIndexes(m_tail, row - 1, col) .

    var E : Element .
    op insertElementIntoMatrix : Matrix Element Int Int -> Matrix .
    eq insertElementIntoMatrix(mnil, E, row, col) = mnil .
    eq insertElementIntoMatrix((m_head | m_tail), E, 0, col) = insertElementIntoVector(m_head, E, col) | m_tail .
    eq insertElementIntoMatrix((m_head | m_tail), E, row, col) = m_head | insertElementIntoMatrix(m_tail, E, row - 1, col) .

endfm

fmod PUZZLE is
    protecting TILE .
    protecting MATRIX .

    sort Puzzle .
    sort Line .

    subsort Puzzle < Matrix .
    subsort Value < Element .
    subsort Line < Vector .

    var head value : Value .
    var tail : Vector .
    var line : Vector .
    var puzzle : Matrix .
    var N x y : Int .

    op getElementByCoords : Matrix Coords -> Value .
    eq getElementByCoords(puzzle, (x ; y)) = getElementByIndexes(puzzle, x, y) .

    op getColumnFromValue : Vector Value -> Int .
    ceq getColumnFromValue((head, tail), value) = 0 if head == value .
    ceq getColumnFromValue(tail, value) = 50 if tail == nil .
    eq getColumnFromValue((head, tail), value) = 1 + getColumnFromValue(tail, value) [ owise ] .

    op getPositionFromValue : Matrix Value -> Coords .
    ceq getPositionFromValue((line | puzzle), value) = 0 ; getColumnFromValue(line, value) if getColumnFromValue(line, value) < 3 .
    eq getPositionFromValue((line | puzzle), value) = incrementRow(getPositionFromValue(puzzle, value)) [ owise ] .

    op getEmptyPosition : Matrix -> Coords .
    eq getEmptyPosition(puzzle) = getPositionFromValue(puzzle, empty) .

    op insertElementIntoPuzzle : Matrix Value Coords -> Matrix .
    eq insertElementIntoPuzzle(puzzle, value, (x ; y)) = insertElementIntoMatrix(puzzle, value, x, y) .

endfm

fmod MOVES is
    protecting INT .
    protecting VECTOR .
    protecting COORDS .
    protecting MATRIX .
    protecting PUZZLE .

    sort Move .
    subsort Bool < Element .
    subsort Move < Element .
    ops LEFT UP RIGHT DOWN : -> Move [ ctor ] .
    
    op getMoveFromIndex : Int Bool -> Move .
    eq getMoveFromIndex(0, true) = LEFT .
    eq getMoveFromIndex(1, true) = UP .
    eq getMoveFromIndex(2, true) = RIGHT .
    eq getMoveFromIndex(3, true) = DOWN .
    eq getMoveFromIndex(N:Int, B:Bool) = nil [ owise ] .

    vars L U R D : Bool .
    op getAvailableMovesFromBoolVector : Vector -> Vector .
    eq getAvailableMovesFromBoolVector(L, U, R, D) = getMoveFromIndex(0, L), getMoveFromIndex(1, U), getMoveFromIndex(2, R), getMoveFromIndex(3, D) .

    vars X Y : Int .
    op getAvailableMoves : Coords -> Vector .
    eq getAvailableMoves(X ; Y) = getAvailableMovesFromBoolVector(Y > 0, X > 0, Y < 2, X < 2) .


    var M : Matrix .

    op move : Matrix Move -> Matrix .
    eq move(M, UP) = insertElementIntoPuzzle(insertElementIntoPuzzle(M, empty, decrementRow( getEmptyPosition( M ) ) ), getElementByCoords(M, decrementRow(getEmptyPosition(M))), getEmptyPosition(M)) .
    eq move(M, DOWN) = insertElementIntoPuzzle(insertElementIntoPuzzle(M, empty, incrementRow( getEmptyPosition( M ) ) ), getElementByCoords(M, incrementRow(getEmptyPosition(M))), getEmptyPosition(M)) .
    eq move(M, LEFT) = insertElementIntoPuzzle(insertElementIntoPuzzle(M, empty, decrementCol( getEmptyPosition( M ) ) ), getElementByCoords(M, decrementCol(getEmptyPosition(M))), getEmptyPosition(M)) .
    eq move(M, RIGHT) = insertElementIntoPuzzle(insertElementIntoPuzzle(M, empty, incrementCol( getEmptyPosition( M ) ) ), getElementByCoords(M, incrementCol(getEmptyPosition(M))), getEmptyPosition(M)) .

endfm

fmod DISTANCE is
    protecting INT .
    protecting MOVES .

    var tile : Value .
    var X Y : Int .
    var c : Coords .
    op getDistanceFromCorrectPosition : Value Coords -> Int .
    eq getDistanceFromCorrectPosition(empty, c) = 0 .
    eq getDistanceFromCorrectPosition(tile, c) = calculateDistance(c, getCorrectPlace(tile)) [ owise ] .

    var head : Value .
    var tail : Vector .
    var row_index col_index : Int .
    op calculateRowScore : Vector Int Int -> Int .
    ceq calculateRowScore(tail, row_index, col_index) = 0 if tail == nil .
    eq calculateRowScore((head, tail), row_index, col_index) = getDistanceFromCorrectPosition(head, (row_index ; col_index)) + calculateRowScore(tail, row_index, col_index + 1) .

    var row : Vector .
    var p : Matrix .

    op calculatePuzzleScore : Matrix Int -> Int .
    ceq calculatePuzzleScore(p, row_index) = 0 if p == mnil .
    eq calculatePuzzleScore((row | p), row_index) = calculateRowScore(row, row_index, 0) + calculatePuzzleScore(p, row_index + 1) .

endfm

fmod CHOICE is
    protecting INT .
    protecting MOVES .
    protecting DISTANCE .

    sort Choice .
    op <_&_> : Matrix Int -> Choice [ ctor frozen prec 50 ] .

    vars p q : Matrix .
    var m n : Move .
    var score_p score_q : Int .
    op getChoice : Move Matrix -> Choice .
    eq getChoice(m, p) = < move(p, m) & calculatePuzzleScore(move(p, m), 0) > .

    op minChoice : Choice Choice -> Choice .
    ceq minChoice(< p & score_p >, < q & score_q >) = < p & score_p > if score_p < score_q .
    eq minChoice(< p & score_p >, < q & score_q >) = < q & score_q > [ owise ] .

    op getPuzzleFromChoice : Choice -> Matrix .
    eq getPuzzleFromChoice(< p & score_p >) = p .

    subsort Choice < Element .
    subsort Move < Element .
    var head : Move .
    var tail row : Vector .
    var moves : Vector .
    op selectChoice : Vector Matrix -> Choice .
    eq selectChoice(nil, p) = < mnil & 10000 > .
    eq selectChoice((head, tail), p) = minChoice(getChoice(head, p), selectChoice(tail, p)) [ owise ] .

    op next : Vector Matrix -> Matrix .
    eq next(moves, p) = getPuzzleFromChoice(selectChoice(moves, p)) .
endfm



mod SLIDING-PUZZLE-GAME is
    protecting PUZZLE .
    protecting MOVES .
    protecting DISTANCE .
    protecting CHOICE .

    op initial : -> Matrix .
    eq initial = (three, one, two) | (seven, empty, four) | (five, eight, six) .

    var puzzle : Matrix .
    ---rl [init] : puzzle => next(initial, getAvailableMoves(getEmptyPosition(initial))) .
    rl [move] : puzzle => next(DOWN, puzzle) .
endm


 ---seven,empty,four, getElementByIndex(nil, 1), 1 ; 1) & calculatePuzzleScore(insertElementIntoPuzzle(three,
---    one,two | seven,empty,four, getElementByIndex(nil, 1), 1 ; 1), 0) >, < mnil & 10000 >))