-------------------------------------------------------------------------------------------
---coordinates of an element in a matrix
fmod COORDS is
    protecting INT .

    sort Coords .

    op _;_ : Int Int -> Coords [ ctor prec 30 ] .

    ---used for searching function in matrix
    vars x y w z : Int .
    op incrementRow : Coords -> Coords .
    eq incrementRow(x ; y) = (x + 1) ; y .

    op incrementCol : Coords -> Coords .
    eq incrementCol(x ; y) = x ; (y + 1) .

    op decrementRow : Coords -> Coords .
    eq decrementRow(x ; y) = (x - 1) ; y .

    op decrementCol : Coords -> Coords .
    eq decrementCol(x ; y) = x ; (y - 1) .

    op calculateDistance : Coords Coords -> Int .
    eq calculateDistance((x ; y), (w ; z)) = abs(x - w) + abs(y - z) .
    

endfm
----------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------
---elements of vectors and matrices
fmod ELEMENT is
    protecting COORDS .

    sort Element .

    ops one two three four five six seven eight empty : -> Element [ ctor ] .

    op getCorrectPlace : Element -> Coords .
    eq getCorrectPlace(one) = (0 ; 0) .
    eq getCorrectPlace(two) = (0 ; 1) .
    eq getCorrectPlace(three) = (0 ; 2) .
    eq getCorrectPlace(four) = (1 ; 0) .
    eq getCorrectPlace(five) = (1 ; 1) .
    eq getCorrectPlace(six) = (1 ; 2) .
    eq getCorrectPlace(seven) = (2 ; 0) .
    eq getCorrectPlace(eight) = (2 ; 1) .

endfm
-----------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------
---vectors
fmod VECTOR is
    protecting ELEMENT .

    sort Vector .
    subsort Element < Vector .

    op nil : -> Vector [ ctor ] .
    op _,_ : Vector Vector -> Vector [ ctor assoc id: nil prec 35] .

    var N : Int .
    var head E : Element .
    var tail : Vector .

    ---get an element from a vector giving an index

    op getElementByIndex : Vector Int -> Vector .
    ---eq getElementByIndex(nil, N) = nil .
    eq getElementByIndex(head, tail, 0) = head .
    eq getElementByIndex(head, tail, N) = getElementByIndex(tail, N - 1) .
    
    ---replace an element in a vector giving his index
    op replaceElementIntoVector : Vector Int Element -> Vector .
    ---eq replaceElementIntoVector(nil, N, E) = nil .
    eq replaceElementIntoVector((head, tail), 0, E) = E, tail .
    eq replaceElementIntoVector((head, tail), N, E) = head, replaceElementIntoVector(tail, N - 1, E) [ owise ] . 

endfm
-----------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------
---matrices
fmod MATRIX is
    protecting VECTOR .

    sort Matrix .
    subsort Vector < Matrix .

    ---NEED mnil, OTHERWISE IT WILL NOT DISTINGUISH VECTORS FROM MATRICES
    op mnil : -> Matrix [ ctor ] .
    op _|_ : Matrix Matrix -> Matrix [ ctor assoc id: mnil prec 40 ] .

    var row tail : Vector .
    var remaining M : Matrix .
    vars row_index col_index : Int .
    var E head : Element .

    ---get an element from a matrix given coordinates

    op getElementByCoords : Matrix Coords -> Element [ strat (1 2 0)] .
    ---eq getElementByCoords(mnil, (row_index ; col_index)) = getElementByIndex(nil, col_index) .
    eq getElementByCoords(row | remaining, (0 ; col_index)) = getElementByIndex(row, col_index) .
    eq getElementByCoords(row | remaining, (row_index ; col_index)) = getElementByCoords(remaining, ((row_index - 1) ; col_index)) .

    ---replace an element in matrix with another element specifying its coordinates

    op replaceElementIntoMatrix : Matrix Coords Element -> Matrix [ strat (2 3 1 0)] .
    ---eq replaceElementIntoMatrix(mnil, (row_index ; col_index), E) = mnil .
    eq replaceElementIntoMatrix((row | remaining), (0 ; col_index), E) = replaceElementIntoVector(row, col_index, E) | remaining .
    eq replaceElementIntoMatrix((row | remaining), (row_index ; col_index), E) = row | replaceElementIntoMatrix(remaining, ((row_index - 1) ; col_index), E) .
    
    ---gets an element's index
    op getIndexFromElement : Vector Element -> Int .
    eq getIndexFromElement((E, tail), E) = 0 .
    ---ceq getIndexFromElement(tail, value) = 50 if tail == nil .
    eq getIndexFromElement((head, tail), E) = 1 + getIndexFromElement(tail, E) [ owise ] .


    ---gets an element's coordinates
    op getCoordsFromElement : Matrix Element -> Coords .
    ceq getCoordsFromElement((row | remaining), E) = 0 ; getIndexFromElement(row, E) if getIndexFromElement(row, E) < 3 .
    eq getCoordsFromElement((row | remaining), E) = incrementRow(getCoordsFromElement(remaining, E)) [ owise ] .

    ---gets empty coordinates
    op getEmptyCoords : Matrix -> Coords .
    eq getEmptyCoords(M) = getCoordsFromElement(M, empty) .

endfm
-----------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------
---moves
fmod MOVE is 
    protecting MATRIX .

    sort Move .
    subsort Move < Element .
    subsort Bool < Element .

    ops LEFT UP RIGHT DOWN : -> Move [ ctor ] .

    ---returns the move based on its index, each index refers to a move (respectively 0 -> LEFT, 1 -> UP, 2 -> RIGHT, 3 -> DOWN)

    op getMoveFromIndex : Int Bool -> Move .
    eq getMoveFromIndex(0, true) = LEFT .
    eq getMoveFromIndex(1, true) = UP .
    eq getMoveFromIndex(2, true) = RIGHT .
    eq getMoveFromIndex(3, true) = DOWN .
    eq getMoveFromIndex(N:Int, B:Bool) = nil [ owise ] .

    ---returns a move vector
    vars X Y : Int .
    op getAvailableMoves : Coords -> Vector .
    eq getAvailableMoves(X ; Y) = getMoveFromIndex(0, Y > 0), getMoveFromIndex(1, X > 0), getMoveFromIndex(2, Y < 2), getMoveFromIndex(3, X < 2) .

    ---moves the empty piece of the puzzle
    var M : Matrix .
    op move : Matrix Move -> Matrix .
    eq move(M, UP) = replaceElementIntoMatrix(replaceElementIntoMatrix(M, decrementRow(getEmptyCoords(M)), empty), getEmptyCoords(M), getElementByCoords(M, decrementRow(getEmptyCoords(M)))) .
    ---eq move(M, DOWN) = replaceElementIntoMatrix(replaceElementIntoMatrix(M, incrementRow(getEmptyCoords(M)), empty), getEmptyCoords(M), getElementByCoords(M, incrementRow(getEmptyCoords(M)))) .
    eq move(M, LEFT) = replaceElementIntoMatrix(replaceElementIntoMatrix(M, decrementCol(getEmptyCoords(M)), empty), getEmptyCoords(M), getElementByCoords(M, decrementCol(getEmptyCoords(M)))) .
    eq move(M, RIGHT) = replaceElementIntoMatrix(replaceElementIntoMatrix(M, incrementCol(getEmptyCoords(M)), empty), getEmptyCoords(M), getElementByCoords(M, incrementCol(getEmptyCoords(M)))) .
    eq move(M, DOWN) = replaceElementIntoMatrix(replaceElementIntoMatrix(M, incrementRow(getEmptyCoords(M)), empty), getEmptyCoords(M), getElementByCoords(M, incrementCol(getEmptyCoords(M)))) .
endfm
-----------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------
---distance
fmod DISTANCE is
    protecting MOVE .

    var E : Element .
    var X Y : Int .
    var c : Coords .
    op getDistanceFromCorrectPosition : Element Coords -> Int .
    eq getDistanceFromCorrectPosition(empty, c) = 0 .
    eq getDistanceFromCorrectPosition(E, c) = calculateDistance(c, getCorrectPlace(E)) [ owise ] .

    var head : Element .
    var tail : Vector .
    var row_index col_index : Int .
    op calculateRowScore : Vector Int Int -> Int .
    ceq calculateRowScore(tail, row_index, col_index) = 0 if tail == nil .
    eq calculateRowScore((head, tail), row_index, col_index) = getDistanceFromCorrectPosition(head, (row_index ; col_index)) + calculateRowScore(tail, row_index, col_index + 1) .

    var row : Vector .
    var p : Matrix .

    op calculatePuzzleScore : Matrix Int -> Int .
    ceq calculatePuzzleScore(p, row_index) = 0 if p == mnil .
    eq calculatePuzzleScore((row | p), row_index) = calculateRowScore(row, row_index, 0) + calculatePuzzleScore(p, row_index + 1) .

endfm
-----------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------
---choice
fmod CHOICE is
    protecting DISTANCE .

    sort Choice .
    op <_&_> : Matrix Int -> Choice [ ctor frozen prec 45 ] .

    vars p q : Matrix .
    var m n : Move .
    var score_p score_q : Int .
    op getChoice : Move Matrix -> Choice .
    eq getChoice(m, p) = < move(p, m) & calculatePuzzleScore(move(p, m), 0) > .

    op minChoice : Choice Choice -> Choice .
    ceq minChoice(< p & score_p >, < q & score_q >) = < p & score_p > if score_p < score_q .
    eq minChoice(< p & score_p >, < q & score_q >) = < q & score_q > [ owise ] .

    op getPuzzleFromChoice : Choice -> Matrix .
    eq getPuzzleFromChoice(< p & score_p >) = p .

    subsort Choice < Element .
    subsort Move < Element .
    var head : Move .
    var tail row : Vector .
    var moves : Vector .
    op selectChoice : Vector Matrix -> Choice .
    eq selectChoice(nil, p) = < mnil & 10000 > .
    eq selectChoice((head, tail), p) = minChoice(getChoice(head, p), selectChoice(tail, p)) [ owise ] .

    op next : Vector Matrix -> Matrix .
    eq next(moves, p) = getPuzzleFromChoice(selectChoice(moves, p)) .
endfm
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
mod SLIDING-GAME is
    protecting CHOICE .

    op initial : -> Matrix .
    eq initial = ((three, one, two) | (seven, four, empty) | (five, eight, six)) .

    var M : Matrix .
    op isSuccess : Matrix -> Bool .
    eq isSuccess((one, two, three) | (four, five, six) | (seven, eight, empty)) = true .
    eq isSuccess(M) = false [ owise ] .

    ---NEED TO CONSIDER A MATRIX COMPOSED BY 3 VECTORS, OTHERWISE THE PROGRAM WILL CONSIDER ONLY MATRICES COMPOSED BY 2
    vars V W Y : Vector .
    ----rl [move] : V | W | Y => move(V | W | Y, DOWN) .
    rl [move] : V | W | Y => next(getAvailableMoves(getEmptyCoords( V | W | Y )), (V | W | Y) ) .
endm